---
title: Exact simulation with Qiskit primitives
description: Simulate with Qiskit reference primitives. How to compute an expectation value with the Estimator primitive, and how to compute circuit output probabilities with the Sampler primitive
---

# Exact simulation with Qiskit primitives

The reference primitives in Qiskit&reg; perform local statevector simulations. These simulations do not support
modeling device noise, but are useful for quickly prototyping algorithms before looking into more advanced simulation
techniques (Qiskit Aer primitives) or running on real devices (Qiskit Runtime primitives).

The `Estimator` primitive can compute expectation values of circuits, and the `Sampler` primitive can sample
from output distributions of circuits.

The following sections show how to use the reference primitives to run your workflow locally.

[//]: # ()
[//]: # (<Admonition type="note">)

[//]: # (  While this guide uses the Qiskit reference implementation, the `Estimator` primitive can be run with any provider using [`qiskit.primitives.BackendEstimator`]&#40;../api/qiskit/qiskit.primitives.BackendEstimator&#41;. There is not yet an equivalent implementation in V2, but it is coming soon.)

[//]: # ()
[//]: # (  ```python)

[//]: # (  from qiskit.primitives import BackendEstimator)

[//]: # (  from <some_qiskit_provider> import QiskitProvider)

[//]: # ()
[//]: # (  provider = QiskitProvider&#40;&#41;)

[//]: # (  backend = provider.get_backend&#40;'backend_name'&#41;)

[//]: # (  estimator = BackendEstimator&#40;backend&#41;)

[//]: # (  ```)

[//]: # ()
[//]: # (  There are some providers that implement primitives natively &#40;see [the Qiskit Ecosystem page]&#40;https://qiskit.github.io/ecosystem/#primitives&#41; for more details&#41;.)

[//]: # (</Admonition>)

[//]: # ()
[//]: # (<Admonition type="note">)

[//]: # (  While this guide uses the Qiskit reference implementation, the `Sampler` primitive can be run with any provider using [`qiskit.primitives.BackendSampler`]&#40;../api/qiskit/qiskit.primitives.BackendSampler&#41;.)

[//]: # ()
[//]: # (  ```python)

[//]: # (  from qiskit.primitives import BackendSampler)

[//]: # (  from <some_qiskit_provider> import QiskitProvider)

[//]: # ()
[//]: # (  provider = QiskitProvider&#40;&#41;)

[//]: # (  backend = provider.get_backend&#40;'backend_name'&#41;)

[//]: # (  sampler = BackendSampler&#40;backend&#41;)

[//]: # (  ```)

[//]: # ()
[//]: # (  There are some providers that implement primitives natively &#40;see [the Qiskit Ecosystem page]&#40;https://qiskit.github.io/ecosystem#providers&#41; for more details&#41;.)

[//]: # (</Admonition>)


## Use the reference `Estimator`

There are two reference implementations of `Estimator` in `qiskit.primitives` that run on a local statevector
simulators, the [`StatevectorEstimator`](../api/qiskit/qiskit.primitives.StatevectorEstimator) class and the
[`Estimator`](../api/qiskit/qiskit.primitives.Estimator) class. The [`StatevectorEstimator`](../api/qiskit/qiskit.primitives.StatevectorEstimator)
implements the new Estimator V2 interface introduced in Qiskit 1.0, and offers additional input vectorization
features in comparison with the [`Estimator`](../api/qiskit/qiskit.primitives.Estimator) class, which implements the
legacy Estimator V1 interface. Both can take circuits, observables and parameters as inputs and return the locally
computed expectation values.

The following code prepares the inputs that will be used in the examples below. The expected input type for the
observables is [`qiskit.quantum_info.SparsePauliOp`](../api/qiskit/qiskit.quantum_info.SparsePauliOp). Note that
the circuit in the example is parametrized, but you can also run the Estimator on non-parametrized circuits.

[//]: # (    The main difference with the previous case is that now you need to specify the sets of parameter values for which you want to evaluate the expectation value as a `list` of `list`s of `float`s.)

[//]: # (The `i`<sup>th</sup> element of the outer `list` is the set of parameter values that corresponds to the `i`<sup>th</sup> circuit and observable.)

<Admonition type="note">
  Any circuit passed to an Estimator must **not** include any **measurements**.
</Admonition>

```python
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.quantum_info import SparsePauliOp

# circuit for which you want to obtain the expected value
qc = QuantumCircuit(2)
qc.ry(Parameter('theta'), 0)
qc.h(0)
qc.cx(0,1)
qc.draw("mpl", style="iqp")

# observable(s) whose expected values you want to compute
observable = SparsePauliOp(["II", "XX", "YY", "ZZ"], coeffs=[1, 1, -1, 1])

# value(s) for the circuit parameter(s)
import numpy as np
theta_values = [[0], [np.pi/6], [np.pi/2]]
```

Note: fix circuit image (doesn't correspond to code)
![Initial QuantumCircuit](/images/verify/simulate-with-qiskit-primitives/estimator-initialize.png "Initial QuantumCircuit")

### Initialize an Estimator

To use the Estimator V2 implementation, follow the instructions to instantiate a
[`qiskit.primitives.StatevectorEstimator`](../api/qiskit/qiskit.primitives.StatevectorEstimator). If you want to maintain
your pre-existing workflow using an Estimator V1 implementation, you can also use the
[`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) class.

<Tabs>
  <TabItem value="EstimatorV2" label="StatevectorEstimator (V2)">
    Instantiate a [`qiskit.primitives.StatevectorEstimator`](../api/qiskit/qiskit.primitives.StatevectorEstimator).

```python
from qiskit.primitives import StatevectorEstimator
estimator = StatevectorEstimator()
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    Instantiate an [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator).

```python
from qiskit.primitives import Estimator
estimator = Estimator()
```
  </TabItem>
</Tabs>


### Run and get results

This example only uses one circuit (of type [`QuantumCircuit`](../api/qiskit/qiskit.circuit.QuantumCircuit)) and one
observable.

[//]: # (I think that we are going to need a page explaining the V2 broadcasting rules with very very clear examples,)

[//]: # (so maybe we can keep the example here simple and not try to squeeze in a fast explanation.)

[//]: # (* For V1 primitives, if you want to get expectation values for multiple circuits and observables, )

[//]: # (you can pass a `list` of [`qiskit.circuit.QuantumCircuit`]&#40;../api/qiskit/qiskit.circuit.QuantumCircuit&#41;s and )

[//]: # (a list of `BaseOperator`s to the [`qiskit.primitives.Estimator.run`]&#40;../api/qiskit/qiskit.primitives.Estimator#run&#41; method. Both `list`s must have the same length.)

[//]: # ()
[//]: # (* The V2 primitives accept **vectorized inputs**, where single circuits can be grouped with array-valued specifications. That is, one circuit can be executed)

[//]: # (  for arrays of `n` parameter sets, `n` observables, or both &#40;in the case of the estimator&#41;. Each group is called a  **primitive unified bloc &#40;PUB&#41;**, and can be represented as a tuple: `&#40;1 x circuit, [n x observables], [n x parameters]&#41;`. Each PUB gets its own result.)

<Tabs>
  <TabItem value="EstimatorV2" label="StatevectorEstimator (V2)">
    Run the estimation by calling the [`StatevectorEstimator.run`](../api/qiskit/qiskit.primitives.StatevectorEstimator#run)
    method, which returns an instance of ... You can get the results from the
    job (as an [`qiskit.primitives....Result`](../api/qiskit/qiskit.primitives.EstimatorResult) object)
    with the [`qiskit.providers....result`](../api/qiskit/qiskit.providers.JobV1#result) method.

```python
job = estimator.run([(qc, observable, parameter_values)])
result = job.result()
print(f" > Result class: {type(result)}")
```
```text
      (fix)
EstimatorResult(values=array([4.]), metadata=[{}])
```
  </TabItem>
  <TabItem value="EstimatorV1" label="Estimator (V1)">
    Run the estimation by calling the [`Estimator.run`](../api/qiskit/qiskit.primitives.Estimator#run) method,
    which returns an instance of [`qiskit.providers.JobV1`](../api/qiskit/qiskit.providers.JobV1). You can get the results from the
    job (as an [`EstimatorResult`](../api/qiskit/qiskit.primitives.EstimatorResult) object)
    with the [`JobV1.result`](../api/qiskit/qiskit.providers.JobV1#result) method.

```python
job = estimator.run(qc, observable, parameter_values)
result = job.result()
print(f" > Result class: {type(result)}")
```
```text
      (fix)
EstimatorResult(values=array([4.]), metadata=[{}])
```
  </TabItem>
</Tabs>

#### Get the expected value from the result

<Tabs>
  <TabItem value="EstimatorV2" label="StatevectorEstimator (V2)">

      The primitives V2 result outputs an array of "Pub results". To retrieve the expectation values and metadata for the first
      (and in this case, only) circuit evaluation, we must access the evaluation data for pub 0:

```python
print(f" > Expectation value: {result[0].data.evs}")
print(f" > Metadata: {result[0].metadata}")
```
```text
... (fix)
...
```
  </TabItem>
  <TabItem value="EstimatorV1" label="Estimator (V1)">

      The primitives V1 result stores an array of values that can be accessed through the attribute
      [`EstimatorResult.values`](../api/qiskit/qiskit.primitives.EstimatorResult#values), to see the values for the first
      (and in this case, only) circuit evaluation, we must access the first item of the array:

```python
print(f" > Expectation value: {result.values[0]}")
print(f" > Metadata: {result.metadata}")
```

```text
... (fix)
...
```

[//]: # (      [`qiskit.primitives.EstimatorResult.values`]&#40;../api/qiskit/qiskit.primitives.EstimatorResult#values&#41; returns a `numpy.ndarray`)

[//]: # (whose `i`<sup>th</sup> element is the expectation value corresponding to the `i`<sup>th</sup> circuit and `i`<sup>th</sup> observable.)
  </TabItem>
</Tabs>


### Set Estimator run options

By default, the reference Estimator performs an exact statevector calculation based on the
[`quantum_info.Statevector`](../api/qiskit/qiskit.quantum_info.Statevector) class.
However, this can be modified to introduce the effect of the sampling overhead (also known as "shot noise").

With the introduction of the new V2 interface, the sampling overhead in the Estimator is now more precisely defined.
The new interface accepts a `precision` argument that expresses the error bars that the
primitive implementation should target for expectation values estimates,
instead of the number of `shots` used in the V1 interface.

[//]: # (    The sampling overhead, commonly exposed by V1 implementations)

[//]: # (  through the `shots` run option, is now an argument of the primitives `run&#40;&#41;` method )

[//]: # (  that can be specified at the **PUB** level.)

[//]: # (  The V2 base classes expose the arguments in formats different from the V1 API:)

[//]: # ()
[//]: # (    * [`BaseSamplerV2.run`]&#40;/api/qiskit/qiskit.primitives.BaseSamplerV2#run&#41;)

[//]: # (      exposes a `shots` argument &#40;similar to the previous workflow&#41;:)

[//]: # (        )
[//]: # (        ```python)

[//]: # (        # Sample two circuits at 128 shots each.)

[//]: # (        sampler_v2.run&#40;[circuit1, circuit2], shots=128&#41;)

[//]: # (        # Sample two circuits at different amounts of shots. The "None"s are necessary)

[//]: # (        # as placeholders)

[//]: # (        # for the lack of parameter values in this example.)

[//]: # (        sampler_v2.run&#40;[&#40;circuit1, None, 123&#41;, &#40;circuit2, None, 456&#41;]&#41;)

[//]: # (        ```)

<Tabs>
  <TabItem value="V2" label="StatevectorEstimator (V2)">

      The sampling overhead is now called `precision`, can is defined exclusively at the `.run()`
      method level. This allows for a finer grained tuning of the option all the way to the pub level.

    ```python
    # Estimate expectation values for two PUBs, both with 0.05 precision.
    estimator_v2.run([(circuit1, obs_array1), (circuit2, obs_array_2)], precision=0.05)
    ```

  </TabItem>

  <TabItem value="V1" label="Estimator (V1)">

      The V1 interface allowed to specify shots by:

        - Setting keyword arguments in the [`qiskit.primitives.Estimator.run`](../api/qiskit/qiskit.primitives.Estimator#run) method.
        - Modifying the [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) options.

    ```python
    job = estimator.run(qc, observable, shots=2048, seed=123)
    result = job.result()
    print(result)
    ```
  </TabItem>
</Tabs>


[//]: # (    By default, the reference [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41; class performs an exact )

[//]: # (      statevector calculation based on the [`qiskit.quantum_info.Statevector`]&#40;../api/qiskit/qiskit.quantum_info.Statevector&#41; class.)

[//]: # (      However, this can be modified to include shot noise if the number of `shots` is set.)

[//]: # (      For reproducibility purposes, a `seed` will also be set in the following examples.)

[//]: # ()
[//]: # (There are two main ways of setting options in the [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41;:)

[//]: # ()
[//]: # (  - Set keyword arguments in the [`qiskit.primitives.Estimator.run`]&#40;../api/qiskit/qiskit.primitives.Estimator#run&#41; method.)

[//]: # (  - Modify [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41; options.)

[//]: # (#### Set keyword arguments for [`qiskit.primitives.Estimator.run`]&#40;../api/qiskit/qiskit.primitives.Estimator#run&#41;)

[//]: # ()
[//]: # (If you only want to change the settings for a specific run, it can be more convenient to set the options inside the [`qiskit.primitives.Estimator.run`]&#40;../api/qiskit/qiskit.primitives.Estimator#run&#41; method. You can do this by passing them as keyword arguments.)

[//]: # ()
[//]: # (<Tabs>)

[//]: # (  <TabItem value="EstimatorV2" label="EstimatorV2">)

[//]: # (    ```python)

[//]: # (        # Estimate expectation values for two PUBs, both with 0.05 precision.)

[//]: # (        estimator_v2.run&#40;[&#40;circuit1, obs_array1&#41;, &#40;circuit2, obs_array_2&#41;], precision=0.05&#41;)

[//]: # (        ```)

[//]: # (  </TabItem>)

[//]: # ()
[//]: # (  <TabItem value="EstimatorV1" label="Estimator &#40;V1&#41;">)

[//]: # (    ```python)

[//]: # (job = estimator.run&#40;qc, observable, shots=2048, seed=123&#41;)

[//]: # (result = job.result&#40;&#41;)

[//]: # (print&#40;result&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (EstimatorResult&#40;values=array&#40;[4.]&#41;, metadata=[{'variance': 3.552713678800501e-15, 'shots': 2048}]&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (print&#40;result.values[0]&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (3.999999998697238)

[//]: # (```)

[//]: # (  </TabItem>)

[//]: # (</Tabs>)

[//]: # ()
[//]: # (#### Modify [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41; options)

[//]: # ()
[//]: # (If you want to keep some configuration values for several runs, it can be better to change the [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41; options. That way you can use the same [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41; object as many times as you wish without having to)

[//]: # (rewrite the configuration values every time you use [`qiskit.primitives.Estimator.run`]&#40;../api/qiskit/qiskit.primitives.Estimator#run&#41;.)

[//]: # ()
[//]: # (#### Modify existing [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41;)

[//]: # ()
[//]: # (If you prefer to change the options of an already-defined [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41;, you can use the method [`qiskit.primitives.Estimator.set_options`]&#40;../api/qiskit/qiskit.primitives.Estimator#set_options&#41; and introduce the new options as keyword arguments.)

[//]: # ()
[//]: # (V1 primitives example: )

[//]: # ()
[//]: # (<Admonition>)

[//]: # ( For V2 primitives, `shots` is now an argument of the primitives `run&#40;&#41;` method.)

[//]: # ( </Admonition>)

[//]: # ()
[//]: # (```python)

[//]: # (estimator.set_options&#40;shots=2048, seed=123&#41;)

[//]: # ()
[//]: # (job = estimator.run&#40;qc, observable&#41;)

[//]: # (result = job.result&#40;&#41;)

[//]: # (print&#40;result&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (EstimatorResult&#40;values=array&#40;[4.]&#41;, metadata=[{'variance': 3.552713678800501e-15, 'shots': 2048}]&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (print&#40;result.values[0]&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (3.999999998697238)

[//]: # (```)

[//]: # ()
[//]: # (#### Define a new [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41; with the options)

[//]: # ()
[//]: # (If you prefer to define a new [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41; with new options, define a `dict` like this one:)

[//]: # ()
[//]: # ()
[//]: # (<Tabs>)

[//]: # (  <TabItem value="EstimatorV2" label="EstimatorV2">)

[//]: # (     For V2 primitives, `shots` is  an argument of the primitives `run&#40;&#41;` method, although you can specify different options, such as `optimization_level`.)

[//]: # ()
[//]: # ( **I'M NOT SURE WHAT TO PUT FOR THIS. ARE THERE ANY OPTIONS STILL AVAILABLE FOR V2 BASE PRIMITIVES?**)

[//]: # ()
[//]: # ()
[//]: # ( ```python)

[//]: # (from qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Options)

[//]: # ()
[//]: # (service = QiskitRuntimeService&#40;&#41;)

[//]: # (options = Options&#40;&#41;)

[//]: # (options.resilience_level = 2)

[//]: # (options.optimization_level = 1)

[//]: # (backend = service.backend&#40;"ibmq_qasm_simulator"&#41;)

[//]: # ()
[//]: # (estimator = Estimator&#40;options=options, backend=backend&#41;)

[//]: # (job = estimator.run&#40;circuits=[psi1], observables=[H1], parameter_values=[theta1]&#41;)

[//]: # (psi1_H1 = job.result&#40;&#41;)

[//]: # (```)

[//]: # (  </TabItem>)

[//]: # ()
[//]: # (  <TabItem value="EstimatorV1" label="Estimator &#40;V1&#41;">)

[//]: # (    ```python)

[//]: # (options = {"shots": 2048, "seed": 123})

[//]: # (```)

[//]: # ()
[//]: # (You can then introduce it into your new [`qiskit.primitives.Estimator`]&#40;../api/qiskit/qiskit.primitives.Estimator&#41; with the `options` argument.)

[//]: # ()
[//]: # (```python)

[//]: # (estimator = Estimator&#40;options=options&#41;)

[//]: # ()
[//]: # (job = estimator.run&#40;qc, observable&#41;)

[//]: # (result = job.result&#40;&#41;)

[//]: # (print&#40;result&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (EstimatorResult&#40;values=array&#40;[4.]&#41;, metadata=[{'variance': 3.552713678800501e-15, 'shots': 2048}]&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (print&#40;result.values[0]&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (3.999999998697238)

[//]: # (```)

[//]: # (  </TabItem>)

[//]: # (</Tabs>)

## Use the reference `Sampler`

Similarly to the Estimator, there are two reference implementations of `Sampler` in `qiskit.primitives`:
the [`StatevectorSampler`](../api/qiskit/qiskit.primitives.StatevectorSampler) class and the
[`Sampler`](../api/qiskit/qiskit.primitives.Sampler) class. The [`StatevectorSampler`](../api/qiskit/qiskit.primitives.StatevectorSampler)
implements the new Estimator V2 interface introduced in Qiskit 1.0, and offers additional input vectorization
features in comparison with the [`Sampler`](../api/qiskit/qiskit.primitives.Sampler) class, which implements the
legacy Sampler V1 interface. Both can take circuits and parameters as inputs and return the results from sampling from
the output probability distributions, but they are expressed in different terms:

- The new StatevectorSampler (V2) output can be expressed as an array of sampled values (bitstring) or "counts"
  for each bitstring present in the output distribution.
- The Sampler (V1) output is always expressed as a "quasi-probability" distribution of output states

The following code prepares the inputs that will be used in the examples below. Note that
the circuit in the example is parametrized, but you can also run the Sampler on non-parametrized circuits.

[//]: # (While this example only uses one [`qiskit.circuit.QuantumCircuit`]&#40;../api/qiskit/qiskit.circuit.QuantumCircuit&#41;, you can sam)

[//]: # (      ple multiple circuits by passing a `list` of [`qiskit.circuit.QuantumCircuit`]&#40;../api/qiskit/qiskit.circuit.QuantumCircuit)

[//]: # (      &#41; instances to the [`qiskit.primitives.Sampler.run`]&#40;../api/qiskit/qiskit.primitives.Sampler#run&#41; method.)

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)
qc.measure_all()
qc.draw("mpl", style="iqp")
```

![Initial QuantumCircuit](/images/verify/simulate-with-qiskit-primitives/sampler-initialize.png "Initial QuantumCircuit")

<Admonition type="note">
Any quantum circuit passed to a Sampler **must** include measurements.
</Admonition>

### Initialize `Sampler`

To use the Sampler V2 implementation, follow the instructions to instantiate a
[`qiskit.primitives.StatevectorSampler`](../api/qiskit/qiskit.primitives.StatevectorSampler). If you want to maintain
your pre-existing workflow using a Sampler V1 implementation, you can also use the
[`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) class.

<Tabs>
  <TabItem value="SamplerV2" label="StatevectorSampler (V2)">
    ```python
from qiskit.primitives import StatevectorSampler

sampler = StatevectorSampler()
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python
from qiskit.primitives import Sampler

sampler = Sampler()
```
  </TabItem>
</Tabs>

### Run and get results

<Tabs>
  <TabItem value="SamplerV2" label="StatevectorSampler (V2)">
    ```python
# execute 1 circuit with 3 parameter sets using Sampler V2
job = sampler_v2.run([(circuit, [vals1, vals2, vals3])])
counts = job.result()[0].data.meas.get_counts()
```
        V2 primitives accept multiple PUBs as inputs, and each pub gets its own result. This
  lets you run different circuits with various parameter/observable combinations,
  which was not always possible in the V1 interface:

```python
# execute 2 circuits with 1 parameter set using Sampler V2
job = sampler_v2.run([(circuit1, vals1), (circuit2, vals1)])
counts1 = job.result()
counts2 = job.result()
```      
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
      Run Sampler by calling the [`qiskit.primitives.Sampler.run`](../api/qiskit/qiskit.primitives.Sampler#run)
method, which returns an instance of [`qiskit.providers.JobV1`](../api/qiskit/qiskit.providers.JobV1).
You can get the results from the job (as a [`qiskit.primitives.SamplerResult`](../api/qiskit/qiskit.primitives.SamplerResult) object)
with the [`qiskit.providers.JobV1.result`](../api/qiskit/qiskit.providers.JobV1#result) method.

    ```python
    job = sampler.run(qc)
    result = job.result()
    print(result)
    ```

    ```python
    SamplerResult(quasi_dists=[{0: 0.4999999999999999, 3: 0.4999999999999999}], metadata=[{}])
    ```
  </TabItem>
</Tabs>

### Get the probability distribution or measurement outcome

As mentioned above, the result retrieval step is different between V1 and V2 interfaces.

The V1 sampler gives access to quasi-probability distributions.

The V2 sampler returns measurement outcome samples in the form of **bitstrings** or
**counts**. The bitstrings show the measurement outcomes, preserving the shot
order in which they were measured. The V2 sampler result objects organize
data in terms of their input circuits' classical register names, for
compatibility with dynamic circuits.

[//]: # (    Even though there is only one circuit in this example, [`qiskit.primitives.SamplerResult.quasi_dists`]&#40;../api/qiskit/qiskit.primitives.SamplerResult#quasi_dists&#41; returns a list of [`qiskit.result.QuasiDistribution`]&#40;../api/qiskit/qiskit.result.QuasiDistribution&#41;s.)

[//]: # (`result.quasi_dists[i]` is the quasi-probability distribution of the `i`<sup>th</sup> circuit.)


<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    <Admonition> The name of the classical register defaults to `"meas"`.
    This name will be used later to access the measurement bitstrings.</Admonition>

      ```python
    # Define quantum circuit with 2 qubits
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()
    circuit.draw()
    ```
    ```python
    # Run using V2 sampler
    result = sampler_v2.run([circuit]).result()
    # Access result data for pub 0
    data_pub = result[0].data
    # Access bitstring for the classical register "meas"
    bitstring = data_pub.meas.get_bitstring()
    print(f"The bitstring shape is: {bitstring.shape}")
    # Get counts for the classical register "meas"
    counts = data_pub.meas.get_counts()
    print(f"The counts are: {counts}")
    ```
    ```text
    The bitstring shape is: (1024, 1)
    The counts are: {'00': 523, '11': 501}
    ```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">

<Admonition type="note">
A quasi-probability distribution differs from a probability distribution in that negative values are also allowed.
However, the quasi-probabilities must sum up to 1 like probabilities.
Negative quasi-probabilities may appear when using error mitigation techniques.
</Admonition>
    ```python
    # Define quantum circuit with 2 qubits
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()
    circuit.draw()
    ```

    ```python
    # Run using V1 sampler
    result = sampler_v1.run(circuit).result()
    quasi_dist = result.quasi_dists[0]
    print(f"The quasi-probability distribution is: {quasi_dist}")
    ```
    ```text
    The quasi-probability distribution is: {0: 0.5, 3: 0.5}
    ```

      If you prefer to see the output keys as binary strings instead of decimal numbers, you can use the [`qiskit.result.QuasiDistribution.binary_probabilities`](../api/qiskit/qiskit.result.QuasiDistribution#binary_probabilities) method.

    ```python
    print(quasi_dist.binary_probabilities())
    ```

    ```python
    {'00': 0.4999999999999999, '11': 0.4999999999999999}
    ```

  </TabItem>
</Tabs>

### Change run options

By default, the reference Sampler performs an exact statevector calculation based on the
[`quantum_info.Statevector`](../api/qiskit/qiskit.quantum_info.Statevector) class.
However, this can be modified to introduce the effect of the sampling overhead (also known as "shot noise").

With the introduction of the new V2 interface, the sampling overhead in the Sampler is now more precisely defined.
The new interface accepts a `shots` argument that can be defined at the "pub level"

<Tabs>
  <TabItem value="V2" label="StatevectorSampler (V2)">

    ```python
    # Sample two circuits at 128 shots each.
    sampler_v2.run([circuit1, circuit2], shots=128)
    # Sample two circuits at different amounts of shots. The "None"s are necessary
    # as placeholders
    # for the lack of parameter values in this example.
    sampler_v2.run([(circuit1, None, 123), (circuit2, None, 456)])
    ```

  </TabItem>

  <TabItem value="V1" label="Sampler (V1)">

      The V1 interface allowed to specify shots by:

        - Setting keyword arguments in the [`Sampler.run`](../api/qiskit/qiskit.primitives.Sampler#run) method.
        - Modifying the [`Sampler`](../api/qiskit/qiskit.primitives.Sampler) options.

    ```python
    job = estimator.run(qc, observable, shots=2048, seed=123)
    result = job.result()
    print(result)
    ```
  </TabItem>
</Tabs>

[//]: # (### Change run options)

[//]: # ()
[//]: # (Your workflow might require tuning primitive run options, such as the number of shots.)

[//]: # ()
[//]: # (By default, the reference [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41; class performs an exact statevector)

[//]: # (calculation based on the [`qiskit.quantum_info.Statevector`]&#40;../api/qiskit/qiskit.quantum_info.Statevector&#41; class. However, this can be)

[//]: # (modified to include shot noise if the number of `shots` is set.)

[//]: # (For reproducibility purposes, a `seed` will also be set in the following examples.)

[//]: # ()
[//]: # (There are two main ways of setting options in the [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41;:)

[//]: # ()
[//]: # (- Set keyword arguments in the [`qiskit.primitives.Sampler.run`]&#40;../api/qiskit/qiskit.primitives.Sampler#run&#41; method.)

[//]: # (- Modify [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41; options.)

[//]: # ()
[//]: # (#### Set keyword arguments for [`qiskit.primitives.Sampler.run`]&#40;../api/qiskit/qiskit.primitives.Sampler#run&#41;)

[//]: # ()
[//]: # (If you only want to change the settings for a specific run, it can be more convenient to set the options inside the [`qiskit.primitives.Sampler.run`]&#40;../api/qiskit/qiskit.primitives.Sampler#run&#41; method. You can do this by passing them as keyword arguments.)

[//]: # ()
[//]: # ()
[//]: # ()
[//]: # (<Tabs>)

[//]: # (  <TabItem value="SamplerV2" label="SamplerV2">)

[//]: # (    ```python)

[//]: # (# Sample two circuits at 128 shots each.)

[//]: # (sampler_v2.run&#40;[circuit1, circuit2], shots=128&#41;)

[//]: # (# Sample two circuits at different amounts of shots. The "None"s are necessary)

[//]: # (# as placeholders)

[//]: # (# for the lack of parameter values in this example.)

[//]: # (sampler_v2.run&#40;[&#40;circuit1, None, 123&#41;, &#40;circuit2, None, 456&#41;]&#41;)

[//]: # (```)

[//]: # (  </TabItem>)

[//]: # ()
[//]: # (  <TabItem value="SamplerV1" label="Sampler &#40;V1&#41;">)

[//]: # (    ```python)

[//]: # (job = sampler.run&#40;qc, shots=2048, seed=123&#41;)

[//]: # (result = job.result&#40;&#41;)

[//]: # (print&#40;result&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (SamplerResult&#40;quasi_dists=[{0: 0.5205078125, 3: 0.4794921875}], metadata=[{'shots': 2048}]&#41;)

[//]: # (```)

[//]: # (  </TabItem>)

[//]: # (</Tabs>)

[//]: # ()
[//]: # (#### Modify [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41; options)

[//]: # ()
[//]: # (If you want to keep some configuration values for several runs, it can be better to change the [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41; options. That way you can use the same [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41; object as many times as you wish without having to rewrite the configuration values every time you use [`qiskit.primitives.Sampler.run`]&#40;../api/qiskit/qiskit.primitives.Sampler#run&#41;.)

[//]: # ()
[//]: # (#### Modify existing [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41; &#40;V1&#41;)

[//]: # ()
[//]: # (If you prefer to change the options of an already-defined [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41;, you can use [`qiskit.primitives.Sampler.set_options`]&#40;../api/qiskit/qiskit.primitives.Sampler#set_options&#41; and introduce the new options as keyword arguments.)

[//]: # ()
[//]: # (```python)

[//]: # (sampler.set_options&#40;shots=2048, seed=123&#41;)

[//]: # ()
[//]: # (job = sampler.run&#40;qc&#41;)

[//]: # (result = job.result&#40;&#41;)

[//]: # (print&#40;result&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (SamplerResult&#40;quasi_dists=[{0: 0.5205078125, 3: 0.4794921875}], metadata=[{'shots': 2048}]&#41;)

[//]: # (```)

[//]: # ()
[//]: # (#### Define a new [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41; with the options)

[//]: # ()
[//]: # (If you prefer, you can define a new [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41; with new options.)

[//]: # ()
[//]: # (<Tabs>)

[//]: # (  <TabItem value="SamplerV2" label="SamplerV2">)

[//]: # (    **I'M NOT SURE WHAT TO PUT FOR THIS. ARE THERE ANY OPTIONS STILL AVAILABLE FOR V2 BASE PRIMITIVES?**)

[//]: # (  </TabItem>)

[//]: # ()
[//]: # (  <TabItem value="SamplerV1" label="Sampler &#40;V1&#41;">)

[//]: # (    Define a `dict` like this one:)

[//]: # ()
[//]: # (```python)

[//]: # (options = {"shots": 2048, "seed": 123})

[//]: # (```)

[//]: # ()
[//]: # (You can then introduce it into your new [`qiskit.primitives.Sampler`]&#40;../api/qiskit/qiskit.primitives.Sampler&#41; with the `options` argument.)

[//]: # ()
[//]: # (```python)

[//]: # (sampler = Sampler&#40;options=options&#41;)

[//]: # ()
[//]: # (job = sampler.run&#40;qc&#41;)

[//]: # (result = job.result&#40;&#41;)

[//]: # (print&#40;result&#41;)

[//]: # (```)

[//]: # ()
[//]: # (```python)

[//]: # (SamplerResult&#40;quasi_dists=[{0: 0.5205078125, 3: 0.4794921875}], metadata=[{'shots': 2048}]&#41;)

[//]: # (```)

[//]: # ()
[//]: # (  </TabItem>)

[//]: # (</Tabs>)

## Next steps

<Admonition type="tip" title="Recommendations">
  - For higher-performance simulation that can handle larger circuits, or to incorporate noise models into your simulation, see [Exact and noisy simulation with Qiskit Aer primitives](simulate-with-qiskit-aer).
  - To learn how to use Quantum Composer for simulation, try the [Explore gates and circuits with the Quantum Composer](https://learning.quantum.ibm.com/tutorial/explore-gates-and-circuits-with-the-quantum-composer) tutorial.
  - Read the [Qiskit Estimator API](/api/qiskit/qiskit.primitives.Estimator) reference.
  - Read the [Qiskit Sampler API](/api/qiskit/qiskit.primitives.Sampler) reference.
  - Learn how to run on a physical system in the [Run](../run) section.
</Admonition>